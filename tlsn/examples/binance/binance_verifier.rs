use std::{str, time::Duration};

use elliptic_curve::pkcs8::DecodePublicKey;

use tlsn_core::proof::{SessionProof, TlsProof};

/// A simple verifier which reads a proof generated by `simple_prover.rs` from "proof.json", verifies
/// it and prints the verified data to the console.
fn main() {
    // Deserialize the proof
    let args: Vec<String> = std::env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} <proof_file>", args[0]);
        std::process::exit(1);
    }
    let proof_file = &args[1];
    let proof = std::fs::read_to_string(proof_file).unwrap();
    let proof: TlsProof = serde_json::from_str(&proof).unwrap();

    let TlsProof {
        // The session proof establishes the identity of the server and the commitments
        // to the TLS transcript.
        session,
        // The substrings proof proves select portions of the transcript, while redacting
        // anything the Prover chose not to disclose.
        substrings,
        ..
    } = proof;

    // Verify the session proof against the Notary's public key
    //
    // This verifies the identity of the server using a default certificate verifier which trusts
    // the root certificates from the `webpki-roots` crate.
    println!("Verifying session proof...");
    session
        .verify_with_default_cert_verifier(notary_pubkey())
        .unwrap();
    println!("Verified");

    let SessionProof {
        // The session header that was signed by the Notary is a succinct commitment to the TLS transcript.
        header,
        // This is the session_info, which contains the server_name, that is checked against the
        // certificate chain shared in the TLS handshake.
        session_info,
        ..
    } = session;

    // The time at which the session was recorded
    let time = chrono::DateTime::UNIX_EPOCH + Duration::from_secs(header.time());

    // Verify the substrings proof against the session header.
    //
    // This returns the redacted transcripts
    println!("Verifying substrings proof...");
    let (mut sent, mut recv) = substrings.verify(&header).unwrap();
    println!("Verified");

    // Replace the bytes which the Prover chose not to disclose with 'X'
    sent.set_redacted(b'X');
    recv.set_redacted(b'X');
    recv.set_private(b'Y');
    // println!("rangeeee: {:?}",substrings );
    // println!("DNS: {:?}", session_info.server_name.as_str());
    assert!(session_info.server_name.as_str() == "api.binance.com", "Expected DNS to be api.binance.com, but got {:?}", session_info.server_name.as_str());
    println!("-------------------------------------------------------------------");
    println!(
        "Successfully verified that the bytes below came from a session with {:?} at {}.",
        session_info.server_name, time
    );
    println!("Note that the bytes which the Prover chose not to disclose are shown as X.");
    println!();
    println!("Bytes sent:");
    println!();
    print!("{}", String::from_utf8(sent.data().to_vec()).unwrap());
    println!();
    println!("Bytes received:");
    println!();
    println!("{}", String::from_utf8(recv.data().to_vec()).unwrap());
    println!("-------------------------------------------------------------------");
}

/// Returns a Notary pubkey trusted by this Verifier
fn notary_pubkey() -> p256::PublicKey {
    let pem_file = str::from_utf8(include_bytes!(
        "../../../notary/server/fixture/notary/notary.pub"
    ))
    .unwrap();
    println!("Notary public key PEM file content:");
    println!("{}", pem_file);

    p256::PublicKey::from_public_key_pem(pem_file).unwrap()
}

use tls_core::{
  verify::WebPkiVerifier,
  anchors::{OwnedTrustAnchor, RootCertStore},
};

pub fn build_cert_verifier() -> WebPkiVerifier {
    let mut root_store = RootCertStore::empty();
    root_store.add_server_trust_anchors(webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
        OwnedTrustAnchor::from_subject_spki_name_constraints(
            ta.subject.as_ref(),
            ta.subject_public_key_info.as_ref(),
            ta.name_constraints.as_ref().map(|nc| nc.as_ref()),
        )
    }));

    use std::fs::File;
    use std::io::BufReader;

    if let Ok(cert_file) = File::open("/root/notary.crt") {
        let reader = BufReader::new(cert_file);
        root_store.add_parsable_certificates(&[reader.buffer().to_vec()]);
    } else {
        eprintln!("Error: Could not open notary.crt");
    }

    WebPkiVerifier::new(root_store, None)
}
